# 新对话提示词 - 逆向分析 OK.exe

## 背景

我正在开发一个游戏封包工具（传奇翎风封包工具），项目状态详见 @.cursor_state.md

## 当前问题

封包加密使用**动态 XOR 表**，每个封包的 XOR 表都不同，导致无法正确解密。

**证据**：
```
封包 #3 (序号3): XOR[10]=0x02, XOR[14]=0x4F
封包 #4 (序号4): XOR[10]=0x01, XOR[14]=0x4B
封包 #8 (序号8): XOR[10]=0x0E, XOR[14]=0x0A
封包 #9 (序号9): XOR[10]=0x0E, XOR[14]=0x0B
```

## 任务目标

从参考程序 @OK.exe 中提取动态 XOR 表生成算法，并用 Python 实现。

## 已知信息

### 封包结构
```
[0]     0x23 (#)           - 固定头
[1]     0x31-0x39         - 序号(1-9循环)
[2-17]  加密数据(16字节)   - 核心数据
[18+]   扩展数据          - 可变长度
[末尾]  0x21 (!)          - 固定尾
```

### 解密后结构
```
[0-3]   参数1 (4字节，小端序)
[4-7]   参数2 (4字节，小端序)
[8-9]   功能码 (2字节，小端序)
[10-11] 参数3 (2字节，小端序)
[12-13] 参数4 (2字节，小端序)
[14-15] 参数5 (2字节，小端序)
```

### 测试数据

**封包 #3 (序号3, 功能码 3011)**:
- 加密: `23 33 3C 3C 3C 3C 3C 3C 3C 3C 3C 3C 3F 3F 3E 6F 70 3D 3D 5C 3C 7B 3C 4C 21`
- 解密: `00 00 00 00 00 00 00 00 C3 0B 3D 01 06 00 3F 01`
- 明文: `发送封包（0，0，3011，317，6，319，）`

**封包 #4 (序号4, 功能码 3011)**:
- 加密: `23 34 3C 3C 3C 3C 3C 3C 3C 3C 3C 3C 3F 3F 3E 6F 74 3D 3C 5C 3C 7B 3C 4C 21`
- 解密: `00 00 00 00 00 00 00 00 C3 0B 3E 01 02 00 3F 01`
- 明文: `发送封包（0，0，3011，318，2，319，）`

更多测试数据见 @jilu/2.txt 和 @jilu/4.txt

## 请你帮我

1. **分析 OK.exe**：
   - 使用 Ghidra 或其他逆向工具
   - 定位解密函数
   - 找到 XOR 表生成算法

2. **提取算法**：
   - 理解算法逻辑
   - 识别输入参数（序号、功能码等）
   - 记录关键常量

3. **Python 实现**：
   - 实现 `generate_xor_table(sequence, function_code)` 函数
   - 使用测试数据验证
   - 确保解密结果与参考程序一致

## 参考文档

详细的逆向分析指南见 @REVERSE_ENGINEERING_GUIDE.md

## 期望输出

1. **算法说明**：
   - XOR 表生成的详细步骤
   - 伪代码或流程图

2. **Python 代码**：
   ```python
   def generate_xor_table(sequence, function_code):
       """动态生成 XOR 表"""
       # 实现代码
       pass
   ```

3. **验证结果**：
   - 使用测试数据验证
   - 确认解密正确

## 注意事项

- ⚠️ OK.exe 文件较大 (6MB)，请分段分析，避免上下文溢出
- ✅ 优先使用 Ghidra 等专业工具，不要重复造轮子
- ✅ 如果遇到困难，可以先分析关键函数片段
- ✅ 重点关注 XOR 操作和循环结构

---

**开始吧！请指导我如何使用 Ghidra 分析 OK.exe，或者直接帮我提取算法。**

